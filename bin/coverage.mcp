#!/usr/bin/env ruby
# frozen_string_literal: true

=begin

# Coverage MCP Server with CLI Interface

A versatile Ruby tool that provides both MCP (Model Context Protocol) server functionality
and command-line interface for analyzing code coverage data from SimpleCov.

## Overview

This program serves dual purposes:

1. **MCP Server Mode**: Provides programmatic access to coverage analysis tools via JSON-RPC over stdio
2. **CLI Mode**: Offers a human-readable coverage report in tabular format

## MCP Server Mode

When executed with data available on stdin (typically from an MCP client), the program
operates as an MCP server that provides coverage analysis tools.

### Available MCP Tools

- `coverage_raw(path, root=".")` - Returns the original SimpleCov 'lines' array for a file
- `coverage_summary(path, root=".")` - Returns {covered, total, pct} summary for a file
- `uncovered_lines(path, root=".")` - Returns uncovered line numbers plus summary
- `coverage_detailed(path, root=".")` - Returns verbose per-line objects [{line,hits,covered}]
- `all_files_coverage(root=".")` - Returns coverage percentages for all project files

### Environment Variables

- `SIMPLECOV_RESULTSET` - Optional explicit path to .resultset.json file

### MCP Server Usage

```bash
# Run as MCP server (when stdin has data from MCP client)
echo '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"coverage_summary","arguments":{"path":"lib/foo.rb"}}}' | ./coverage.mcp
```

## CLI Mode

When executed with empty stdin, the program provides a clean
tabular report of coverage for all files in the project.

### CLI Usage Examples

```bash
# Show coverage report for all files (relative to current directory)
bin/coverage.mcp
```

### CLI Output Format

The CLI output is formatted as a clean table with box-style borders and the following columns:

```
┌───────────────────────────┬──────────┬──────────┬────────┐
│ File                      │        % │  Covered │  Total │
├───────────────────────────┼──────────┼──────────┼────────┤
│ lib/models/user.rb        │    92.31 │       12 │     13 │
│ lib/services/auth.rb      │   100.00 │        8 │      8 │
│ spec/user_spec.rb         │    85.71 │       12 │     14 │
└───────────────────────────┴──────────┴──────────┴────────┘
```

Files are sorted by:
1. **Primary**: Coverage percentage (ascending - lowest first)
2. **Secondary**: File path (alphabetical order)

## Data Sources

The program reads SimpleCov coverage data from `.resultset.json` files. It searches
for the resultset in the following locations:

1. `.resultset.json` (current directory)
2. `coverage/.resultset.json`
3. `tmp/.resultset.json`

The search can be overridden using the `SIMPLECOV_RESULTSET` environment variable.

## File Path Resolution

- **CLI Output**: File paths are shown relative to the current working directory
- **MCP Mode**: All file path resolution is relative to the specified or current root directory
- **Fallback**: Uses filename matching when exact path resolution fails

## Dependencies

- `json` - JSON parsing
- `pathname` - Path manipulation
- `mcp` - MCP framework
- `awesome_print` - Formatted output for debugging
- `time` - Timestamp handling

## Usage Detection

The program automatically determines its mode based on input:

1. **CLI Mode**: When called with empty stdin
2. **MCP Server Mode**: When called with data on stdin

## Error Handling

- Provides clear error messages for missing files or invalid paths
- Gracefully handles missing .resultset.json files with helpful guidance
- Logs detailed debugging information to `~/coverage_mcp.log`

=end

require "json"
require "time"
require "pathname"
require "mcp"
require "mcp/server/transports/stdio_transport"
require "awesome_print"

# Input read from stdin is treated as coming from an MCP client.
# Responses are sent to stdout.

RESULTSET_CANDIDATES = [
  ".resultset.json",
  "coverage/.resultset.json",
  "tmp/.resultset.json"
].freeze

# ---------- helpers ----------
module CovUtil
  module_function

  def find_resultset(root)
    if (env = ENV["SIMPLECOV_RESULTSET"]) && !env.empty?
      path = File.absolute_path(env, root)
      return path if File.file?(path)
    end
    RESULTSET_CANDIDATES
      .map { |p| File.absolute_path(p, root) }
      .find { |p| File.file?(p) } or
      raise "Could not find .resultset.json under #{root.inspect}; run tests or set SIMPLECOV_RESULTSET"
  end

  # returns { abs_path => {"lines" => [hits|nil,...]} }
  def load_latest_coverage(root)
    rs = find_resultset(root)
    raw = JSON.parse(File.read(rs))
    _suite, data = raw.max_by { |_k, v| (v["timestamp"] || v["created_at"] || 0).to_i }
    cov = data["coverage"] or raise "No 'coverage' key in .resultset.json"
    cov.transform_keys { |k| File.absolute_path(k, root) }
  end

  def lookup_lines(cov, file_abs)
    if (h = cov[file_abs]) && h["lines"].is_a?(Array)
      return h["lines"]
    end

    # try without current working directory prefix
    cwd = Dir.pwd
    without = file_abs.sub(/\A#{Regexp.escape(cwd)}\//, "")
    if (h = cov[without]) && h["lines"].is_a?(Array)
      return h["lines"]
    end

    # fallback: basename match
    base = File.basename(file_abs)
    kv = cov.find { |k, v| File.basename(k) == base && v["lines"].is_a?(Array) }
    kv and return kv[1]["lines"]

    raise "No coverage entry found for #{file_abs}"
  end

  def summary(arr)
    total = 0
    covered = 0
    arr.each do |hits|
      next if hits.nil?
      total += 1
      covered += 1 if hits.to_i > 0
    end
    pct = total.zero? ? 100.0 : ((covered.to_f * 100.0 / total) * 100).round / 100.0
    { "covered" => covered, "total" => total, "pct" => pct }
  end

  def uncovered(arr)
    out = []
    arr.each_with_index do |hits, i|
      next if hits.nil?
      out << (i + 1) if hits.to_i.zero?
    end
    out
  end

  def detailed(arr)
    rows = []
    arr.each_with_index do |hits, i|
      next if hits.nil?
      h = hits.to_i
      rows << { line: i + 1, hits: h, covered: h.positive? }
    end
    rows
  end

  # resolve inputs → [abs_file, lines_array]
  def resolve(root, path)
    root = File.absolute_path(root || ".")
    abs  = File.absolute_path(path, root)
    cov  = load_latest_coverage(root)
    [abs, lookup_lines(cov, abs)]
  end
end

# ---------- tool base ----------
class BaseTool < MCP::Tool
  INPUT_SCHEMA = {
    type: "object",
    properties: {
      path: { type: "string", description: "Absolute or project-relative file path" },
      root: { type: "string", description: "Project root for resolution", default: "." }
    },
    required: ["path"]
  }
  def self.input_schema_def = INPUT_SCHEMA
end

# ---------- tools ----------
class CoverageRaw < BaseTool
  description "Return the original SimpleCov 'lines' array for a file"
  input_schema(**input_schema_def)
  class << self
    def call(path:, root: ".", server_context:)
      file, arr = CovUtil.resolve(root, path)
      MCP::Tool::Response.new([{ type: "json", json: { file: file, lines: arr } }],
                              meta: { mimeType: "application/json" })
    rescue => e
      MCP::Tool::Response.new([{ type: "text", text: "Error: #{e.class}: #{e.message}" }])
    end
  end
end

class CoverageSummary < BaseTool
  description "Return {covered,total,pct} for a file"
  input_schema(**input_schema_def)
  class << self
    def call(path:, root: ".", server_context:)
      file, arr = CovUtil.resolve(root, path)
      sum = CovUtil.summary(arr)
      MCP::Tool::Response.new([{ type: "json", json: { file: file, summary: sum } }],
                              meta: { mimeType: "application/json" })
    rescue => e
      MCP::Tool::Response.new([{ type: "text", text: "Error: #{e.class}: #{e.message}" }])
    end
  end
end

class UncoveredLines < BaseTool
  description "Return only uncovered executable line numbers plus a summary"
  input_schema(**input_schema_def)
  class << self
    def call(path:, root: ".", server_context:)
      file, arr = CovUtil.resolve(root, path)
      list = CovUtil.uncovered(arr)
      sum  = CovUtil.summary(arr)
      MCP::Tool::Response.new([{ type: "json", json: { file: file, uncovered: list, summary: sum } }],
                              meta: { mimeType: "application/json" })
    rescue => e
      MCP::Tool::Response.new([{ type: "text", text: "Error: #{e.class}: #{e.message}" }])
    end
  end
end

class CoverageDetailed < BaseTool
  description "Verbose per-line objects [{line,hits,covered}] (token-heavy)"
  input_schema(**input_schema_def)
  class << self
    def call(path:, root: ".", server_context:)
      file, arr = CovUtil.resolve(root, path)
      rows = CovUtil.detailed(arr)
      sum  = CovUtil.summary(arr)
      MCP::Tool::Response.new([{ type: "json", json: { file: file, lines: rows, summary: sum } }],
                              meta: { mimeType: "application/json" })
    rescue => e
      MCP::Tool::Response.new([{ type: "text", text: "Error: #{e.class}: #{e.message}" }])
    end
  end
end

class AllFilesCoverage < MCP::Tool
  description "Return coverage percentage for all files in the project"
  input_schema(
    type: "object",
    properties: {
      root: { type: "string", description: "Project root for resolution", default: "." },
      sort_order: { type: "string", description: "Sort order for coverage percentage: ascending or descending", default: "ascending", enum: ["ascending", "descending"] }
    }
  )
  class << self
    def call(root: ".", sort_order: "ascending", server_context:)
      root = File.absolute_path(root || ".")
      cov = CovUtil.load_latest_coverage(root)
      
      file_summaries = cov.map do |abs_path, data|
        next unless data["lines"].is_a?(Array)
        
        summary = CovUtil.summary(data["lines"])
        {
          file: abs_path,
          covered: summary["covered"],
          total: summary["total"],
          percentage: summary["pct"]
        }
      end.compact
      
      # Sort by percentage (ascending/descending) then by filespec (always ascending)
      file_summaries.sort! do |a, b|
        pct_comparison = sort_order == "descending" ? 
          b[:percentage] <=> a[:percentage] : 
          a[:percentage] <=> b[:percentage]
        pct_comparison == 0 ? a[:file] <=> b[:file] : pct_comparison
      end
      
      MCP::Tool::Response.new([{ type: "json", json: { files: file_summaries } }],
                              meta: { mimeType: "application/json" })
    rescue => e
      MCP::Tool::Response.new([{ type: "text", text: "Error: #{e.class}: #{e.message}" }])
    end
  end
end

# ---------- CLI interface ----------
class CoverageCLI
  def initialize
    @root = "."
  end

  def run(_argv)
    if stdin_empty?
      show_default_report
    else
      run_mcp_server
    end
  end

  private

  def stdin_empty?
    # Check if stdin has data available to read
    !select([$stdin], nil, nil, 0.1)
  end

  def show_default_report
    puts "This program is primarily an MCP server that takes input from an MCP client on stdin,"
    puts "and sends JSON responses to stdout."
    puts ""
    puts "Running as standalone CLI to show coverage report:"
    puts ""

    # Reuse the all-files logic to show the report
    @root = "."
    handle_all_files
  end

  def handle_all_files
    root = File.absolute_path(@root)
    cov = CovUtil.load_latest_coverage(root)

    file_summaries = cov.map do |abs_path, data|
      next unless data["lines"].is_a?(Array)

      summary = CovUtil.summary(data["lines"])
      # Convert absolute path to relative path from current working directory
      relative_path = Pathname.new(abs_path).relative_path_from(Pathname.new(Dir.pwd)).to_s
      {
        file: relative_path,
        covered: summary["covered"],
        total: summary["total"],
        percentage: summary["pct"]
      }
    end.compact.sort_by { |f| [f[:percentage], f[:file]] }

    # Format as table with box-style borders
    max_file_length = file_summaries.map { |f| f[:file].length }.max.to_i
    max_file_length = [max_file_length, "File".length].max

    # Calculate maximum numeric values for proper column widths
    max_covered = file_summaries.map { |f| f[:covered].to_s.length }.max
    max_total = file_summaries.map { |f| f[:total].to_s.length }.max

    # Define column widths
    file_width = max_file_length + 2  # Extra padding
    pct_width = 8
    covered_width = [max_covered, "Covered".length].max + 2
    total_width = [max_total, "Total".length].max + 2

    # Horizontal line for each column span
    h_line = ->(col_width) { '─' * (col_width + 2) }

    # Border line lambda
    border_line = ->(left, middle, right) {
        left   + h_line.(file_width) +
        middle + h_line.(pct_width) +
        middle + h_line.(covered_width) +
        middle + h_line.(total_width) +
        right
    }

    # Top border
    puts border_line.call("┌", "┬", "┐")

    # Header row
    printf "│ %-#{file_width}s │ %#{pct_width}s │ %#{covered_width}s │ %#{total_width}s │\n",
           "File", " %", "Covered", "Total"

    # Header separator
    puts border_line.call("├", "┼", "┤")

    # Data rows
    file_summaries.each do |file_data|
      printf "│ %-#{file_width}s │ %#{pct_width - 1}.2f%% │ %#{covered_width}d │ %#{total_width}d │\n", 
             file_data[:file], 
             file_data[:percentage],
             file_data[:covered], 
             file_data[:total]
    end
    
    # Bottom border
    puts border_line.call("└", "┴", "┘")
  end

  def run_mcp_server
    server = MCP::Server.new(
      name:    "ruby_coverage_server",
      version: "0.5.0",
      tools:   [CoverageRaw, CoverageSummary, UncoveredLines, CoverageDetailed, AllFilesCoverage]
    )
    MCP::Server::Transports::StdioTransport.new(server).open
  end
end

# ---------- main execution ----------
if __FILE__ == $0
  CoverageCLI.new.run(ARGV)
end
